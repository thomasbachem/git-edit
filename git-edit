#!/bin/zsh

# git edit – Easily edit commits via interactive rebase
# usage: `git-edit [-m | --message | -d | --drop | -s | --squash] <commit>`
#
# This Git command script allows you to edit/modify/modify
# previous Git commits easily. It essentially is a more
# convenient version of using `git rebase --interactive`
# for that use case.
#
# It will stash any local changes, then reset your local copy
# to the state of the commit you want to edit via `git rebase`,
# then pause to let you make changes. After resuming the script,
# all changes will be added to the commit, and the rebase will
# continue. The script also pauses in case any conflicts arise,
# so you can manually resolve them before continuing with the
# merge/rebase. After completion, your previous local changes
# will be unstashed/reapplied.
#
# If you want to alter the commit message as well, add the
# `-m` switch. You can also delete (drop) a commit by using
# `-d` instead, or merge (fixup/squash) it into the previous one
# using `-s`/`--squash`.
#
# Use it as "git edit" by adding its parent folder to your PATH,
# e.g. by adding this line to ~./zshrc:
# export PATH=$PATH:/your/path/to/git-custom-commands
#
# WARNING: Note that this will change the SHA1 of the commit
# as well as of all later commmits – it rewrites the history
# from that point forward. This is unproblematic as long as
# you either didn't push these commits yet, or are a single
# developer. If not, it can cause other maintainers, branches,
# or forks quite the hassle. So please know what you're doing
# when using `git push --force`!
#
# Released by Thomas Bachem <mail@thomasbachem.com>
# under the MIT License


# Make a pipeline fail if any element fails
# (required for `$?` to work in conjunction with `tee` below)
set -o pipefail

echo -e "\e[1;96mgit edit – Easily edit commits via interactive rebase\e[0m"


# ------------------------------------------- FUNCTIONS --------------------------------------------

USAGE () {
	echo -e "\e[0;96musage: git edit [-m | --message | -d | --drop | -s | --squash] <commit>\e[0m"
	echo -e ""
	echo -e "\e[0;96m       -m, --message     Alter commit message after editing\e[0m"
	echo -e "\e[0;96m       -d, --drop        Just delete (drop) the commit\e[0m"
	echo -e "\e[0;96m       -s, --squash      Merge (fixup/squash) this commit into the previous one\e[0m"
	echo -e ""
}

PRINT_CMD () {
	# First arg is the full command string to be printed
	local CMD="$1"

	# Filter `--no-autostash` arg when printing commands
	local CMD_FILTERED=$(echo "$CMD" | sed -E 's/(^| )--no-autostash($| )/ /g; s/  +/ /g')

	echo -e "\n\e[0;97m$CMD_FILTERED\e[0;90m"
}

PRINT_ERR () {
	local MSG="$1"

	if [[ "$MSG" == *:* ]]; then
		local PREFIX="${MSG%%:*}"
		local REST="${MSG#*: }"
		echo -e "\n\e[1;91m${PREFIX}:\e[0m\e[0;91m ${REST}\e[0m" >&2
	else
		echo -e "\n\e[1;91m${MSG}\e[0m" >&2
	fi
}

GIT_STASH () {
	local CMD="git stash push -u"
	PRINT_CMD "$CMD"

	local OUTPUT STATUS # Needs to be separate for `$?` to work properly
	OUTPUT=$(eval "$CMD -m '$COMMANDLINE'")
	STATUS=$?
	
	if [[ $STATUS -ne 0 ]]; then
		ABORT
	elif [[ "$OUTPUT" == *"Saved working directory"* ]]; then
		STASH_REF="stash@{0}"
	fi
}

GIT_UNSTASH () {
	if [ -n "$STASH_REF" ]; then
		local CMD="git stash pop"
		PRINT_CMD "$CMD"

		eval "$CMD '$STASH_REF'"
		unset STASH_REF
	fi
}

GIT_REBASE_DROP () {
	# Determine if commit has a parent or is the first commit
	if git show -s --pretty=%P "$COMMIT_SHORT" | grep -q .; then
		local CMD=(rebase --no-autostash --interactive "$COMMIT_SHORT~")
	else
		local CMD=(rebase --no-autostash --interactive --root)
	fi
	PRINT_CMD "git ${CMD[*]} # -> drop"

	GIT_SEQUENCE_EDITOR="sed -i -e 's/^pick $COMMIT_SHORT/drop $COMMIT_SHORT/'" git "${CMD[@]}" || ABORT
}

GIT_REBASE_SQUASH () {
	local CMD=(rebase --no-autostash --interactive "$COMMIT_SHORT~2")
	PRINT_CMD "git ${CMD[*]} # -> squash"

	local OUTPUT STATUS # Needs to be separated for `$?` to work properly
	OUTPUT=$(GIT_SEQUENCE_EDITOR="sed -i -e 's/^pick $COMMIT_SHORT/squash $COMMIT_SHORT/'" git "${CMD[@]}" 2>&1 | tee /dev/stderr)
	STATUS=$?

	GIT_REBASE_HANDLE_ERRORS "$OUTPUT" $STATUS
}

GIT_REBASE_FIXUP () {
	local CMD=(rebase --no-autostash --interactive "$COMMIT_SHORT~2")
	PRINT_CMD "git ${CMD[*]} # -> fixup"

	local OUTPUT STATUS # Needs to be separated for `$?` to work properly
	OUTPUT=$(GIT_SEQUENCE_EDITOR="sed -i -e 's/^pick $COMMIT_SHORT/fixup $COMMIT_SHORT/'" git "${CMD[@]}" 2>&1 | tee /dev/stderr)
	STATUS=$?

	GIT_REBASE_HANDLE_ERRORS "$OUTPUT" $STATUS
}

GIT_REBASE_BEGIN_EDIT () {
	# Determine if commit has a parent or is the first commit
	if git show -s --pretty=%P "$COMMIT_SHORT" | grep -q .; then
		local CMD=(rebase --no-autostash --interactive "$COMMIT_SHORT~")
	else
		local CMD=(rebase --no-autostash --interactive --root)
	fi
	PRINT_CMD "git ${CMD[*]} # -> edit"

	GIT_SEQUENCE_EDITOR="sed -i -e 's/^pick $COMMIT_SHORT/edit $COMMIT_SHORT/'" git "${CMD[@]}" || ABORT
}

GIT_ADD_ALL () {
	local CMD="git add --all"
	PRINT_CMD "$CMD"

	eval "$CMD" || ABORT
}

GIT_COMMIT_AMEND () {
	if [ ${#OPT_MESSAGE} -gt 0 ]; then
		local CMD="git commit --all --amend"
	else
		local CMD="git commit --all --amend --no-edit"
	fi
	PRINT_CMD "$CMD"

	eval "$CMD" || ABORT
}

GIT_REBASE_CONTINUE () {
	# First arg is the rebase sub-command, defaulting to "--continue"
	local SUBCMD="${1:---continue}"

	local CMD="git rebase $SUBCMD"
	PRINT_CMD "$CMD"

	local OUTPUT STATUS # Needs to be separated for `$?` to work properly
	OUTPUT=$(eval "GIT_EDITOR=true $CMD" 2>&1 | tee /dev/stderr)
	STATUS=$?

	GIT_REBASE_HANDLE_ERRORS "$OUTPUT" $STATUS
}

GIT_REBASE_HANDLE_ERRORS () {
	local OUTPUT="$1"
	local STATUS=$2

	if [[ $STATUS -ne 0 ]]; then
		if [[ "$OUTPUT" == *"CONFLICT (content)"* ]]; then
			echo -e "\n\e[1;93mMerge conflicts\e[0;93m – Resolve them and press \e[1;93mEnter\e[0;93m to continue, or \e[1;93mEscape\e[0;93m to cancel your edit.\e[0m"
			CONTINUE_OR_ABORT

			GIT_ADD_ALL
			GIT_REBASE_CONTINUE
		elif [[ "$OUTPUT" == *"--allow-empty"* ]]; then
			echo -e "\n\e[1;93mA later commit is now empty\e[0;93m – Press \e[1;93mEnter\e[0;93m to skip (drop) it, or \e[1;93mEscape\e[0;93m to cancel your edit.\e[0m"
			CONTINUE_OR_ABORT

			GIT_ADD_ALL
			GIT_REBASE_CONTINUE "--skip"
		else
			PRINT_ERR "Unknown error during rebase."
			ABORT
		fi
	fi
}

CONTINUE_OR_ABORT () {
	while true; do
		IFS= read -rs -k1 KEY
		echo
		case $KEY in
			''|$'\r'|$'\n') break ;;
			$'\e')          ABORT ;;
			*)              echo "Unknown key, try again." ;;
		esac
	done
}

ABORT () {
	local CMD="git rebase --abort"
	PRINT_CMD "$CMD"

	eval "$CMD" 2>/dev/null

	GIT_UNSTASH

	PRINT_ERR "Aborted."
	exit 1
}


# ---------------------------------------- ARGUMENT PARSING ----------------------------------------

# Remember full original command line
COMMANDLINE="git edit"
for ARG in "$@"; do
	COMMANDLINE+=" $(printf '%q' "$ARG")"
done

# -D pulls parsed flags out of $@
# -E allows flags/args and positionals to be mixed
# -F says fail if we find a flag that wasn't defined
# -K allows us to set default values without zparseopts overwriting them
# (the first dash is automatically handled, so long options are -opt, not --opt)
zmodload zsh/zutil
if ! zparseopts -D -E -F -K -- {m,-message}=OPT_MESSAGE {d,-drop}=OPT_DROP {s,-squash}=OPT_SQUASH {h,-help}=OPT_HELP; then
	USAGE
	PRINT_ERR "Unknown option: $1"
	exit 1
fi

# -h/--help/help
if [[ ${#OPT_HELP} -gt 0 || $1 == "help" ]]; then
	USAGE
	exit 0
fi

# -m/--message + -d/--drop
if [ ${#OPT_MESSAGE} -gt 0 -a ${#OPT_DROP} -gt 0 ]; then
	USAGE
	PRINT_ERR "Options -m/--message and -d/--drop cannot be combined"
	exit 1
fi
# -d/--drop + -s/--squash
if [ ${#OPT_DROP} -gt 0 -a ${#OPT_SQUASH} -gt 0 ]; then
	USAGE
	PRINT_ERR "Options -d/--drop and -s/--squash cannot be combined"
	exit 1
fi
# -d/--drop | -s/--squash
if [ ${#OPT_DROP} -gt 0 ]; then
	ACTION="drop"
elif [ ${#OPT_SQUASH} -gt 0 ]; then
	ACTION="squash"
else
	ACTION="edit"
fi

# <commit>
if [ $# -eq 0 ]; then
	USAGE
	PRINT_ERR "Missing <commit> argument"
	exit 1
else
	COMMIT=$1
	shift
	if [ $# -ne 0 ]; then
		USAGE
		PRINT_ERR "Only one <commit> argument is allowed"
		exit 1
	fi
fi
COMMIT_SHORT=${COMMIT:0:7}


# ------------------------------------------- CORE LOGIC -------------------------------------------

GIT_STASH

if [[ "$ACTION" == "drop" ]]; then
	echo -e "\n\e[1;96mDropping commit \e[0;96m$COMMIT_SHORT\e[0m"

	GIT_REBASE_DROP
elif [[ "$ACTION" == "squash" ]]; then
	echo -e "\n\e[1;96mMerging commit \e[0;96m$COMMIT_SHORT\e[1;96m into previous commit\e[0m"

	if [ ${#OPT_MESSAGE} -gt 0 ]; then
		GIT_REBASE_SQUASH
	else
		GIT_REBASE_FIXUP
	fi
else
	GIT_REBASE_BEGIN_EDIT
	 
	echo -e "\n\e[1;96mNow make your changes\e[0;96m – then press \e[1;96mEnter\e[0;96m to continue, or cancel with \e[1;96mEscape\e[0;96m.\e[0m"
	CONTINUE_OR_ABORT

	GIT_ADD_ALL
	GIT_COMMIT_AMEND

	GIT_REBASE_CONTINUE
fi

GIT_UNSTASH

echo -e "\n\e[1;92mgit edit completed.\e[0m"
