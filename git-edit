#!/bin/zsh

# git edit – Easily edit commits via interactive rebase
#
# usage: `git-edit [-m | --message] <commit>`
#    or: `git-edit [-d | --drop | -s | --squash] <commit>...`
#
# This Git command script allows you to edit/modify/merge
# previous Git commits easily. It essentially is a more
# convenient version of using `git rebase --interactive`
# for that use case.
#
# It will stash any local changes, then reset your local copy
# to the state of the commit you want to edit via `git rebase`,
# then pause to let you make changes. After resuming the script,
# all changes will be added to the commit, and the rebase will
# continue. The script also pauses in case any conflicts arise,
# so you can manually resolve them before continuing with the
# merge/rebase. After completion, your previous local changes
# will be unstashed/reapplied.
#
# If you want to alter the commit message as well, add the
# `-m` switch. You can also delete (drop) one or more commits
# (or ranges) by using `-d`, or merge (fixup/squash) one or
# more commits into another one (defaulting to the oldest
# commit in the selection) using `-s`/`--squash`. Whenever
# multiple commit hashes are supplied, `-s`/`--squash` is
# assumed as the default mode and the oldest commit becomes
# the `<target>`.
#
# Use it as "git edit" by adding its parent folder to your PATH,
# e.g. by adding this line to ~./zshrc:
# export PATH=$PATH:/your/path/to/git-custom-commands
#
# WARNING: Note that this will change the SHA1 of the commit
# as well as of all later commmits – it rewrites the history
# from that point forward. This is unproblematic as long as
# you either didn't push these commits yet, or are a single
# developer. If not, it can cause other maintainers, branches,
# or forks quite the hassle. So please know what you're doing
# when using `git push --force`!
#
# Released by Thomas Bachem <mail@thomasbachem.com>
# under the MIT License


# Make a pipeline fail if any element fails
# (required for `$?` to work in conjunction with `tee` below)
set -o pipefail

echo -e "\e[1;94mgit edit – Easily edit commits via interactive rebase\e[0m"


# ------------------------------------------- FUNCTIONS --------------------------------------------

USAGE () {
	echo -e "\e[0;94musage: git edit [-m | --message | -s | --squash] <commit> [<target>]\e[0m"
	echo -e "\e[0;94m       git edit [-d | --drop] <commit>...\e[0m"
	echo -e ""
	echo -e "\e[0;94m       -m, --message                   Alter <commit> message after editing\e[0m"
	echo -e "\e[0;94m       -d, --drop                      Just delete (drop) one or more <commit>s or ranges\e[0m"
	echo -e "\e[0;94m       -s, --squash                    Merge (fixup/squash) <commit> into the previous one\e[0m"
	echo -e "\e[0;94m       -s <target>, --squash <target>  Merge (fixup/squash) <commit> into <target>\e[0m"
}

PRINT_TEXT () {
	local MSG=$1; shift
	local COLOR=$1; shift
	local ARGS=("$@")

	local BASE=$COLOR
	local BRIGHT=$(( COLOR <= 37 ? COLOR + 60 : COLOR ))

	local TEXT="$MSG"
	local OUTPUT="\n\e[0;${COLOR}m"
	local ARG
	for ARG in "${ARGS[@]}"; do
		OUTPUT+="${TEXT%%%s*}"
		OUTPUT+="\e[1;${BRIGHT}m${ARG}\e[0;${BASE}m"
		TEXT="${TEXT#*%s}"
	done
	OUTPUT+="$TEXT\e[0m"
	echo -e "$OUTPUT"
}

PRINT_ACTION () {
	local MSG=$1; shift
	local COMMITS=("$@")

	local ARGS=()
	local COMMIT
	for COMMIT in "${COMMITS[@]}"; do
		local SUBJECT=$(git log -1 --pretty=format:'%s' "$COMMIT")
		ARGS+=("${COMMIT:0:7}\e[22m (${SUBJECT})")
	done

	# Count placeholders (assumes %s is the only placeholder type used)
	local PLACEHOLDERS="${MSG//[^%]}"
	
	# Use list mode if multiple commits or if it's a merge (contains "->")
	if [[ ${#COMMITS[@]} -gt 1 || "$MSG" == *"->"* ]] && [[ ${#PLACEHOLDERS} -eq 1 ]]; then
		local PREFIX="${MSG%%%s*}" # e.g. "Dropping "
		local SUFFIX="${MSG#*%s}"  # e.g. "..."

		# Transform "Dropping " -> "Dropping:"
		local NEW_MSG="${PREFIX% }:"

		# Append a newline and indented placeholder for every commit
		# We use a C-style loop for robust iteration in Zsh
		for (( i=0; i<${#COMMITS[@]}; i++ )); do
			NEW_MSG+="\n - %s"
		done

		# Put merge arrow on a new line and bold it, otherwise keep suffix attached
		if [[ "$SUFFIX" == *"->"* ]]; then
			NEW_MSG+="\n\e[1;96m${SUFFIX# }"
		else
			NEW_MSG+="$SUFFIX"
		fi
		
		PRINT_TEXT "$NEW_MSG" 36 "${ARGS[@]}"
	else
		# Default behavior for single commits or specific pairs (squash A -> B)
		PRINT_TEXT "$MSG" 36 "${ARGS[@]}"
	fi
}

PRINT_CMD () {
	# First arg is the full command string to be printed
	local CMD="$1"

	# Filter `--no-autostash` arg when printing commands
	local CMD_FILTERED=$(echo "$CMD" | sed -E 's/(^| )--no-autostash($| )/ /g; s/  +/ /g')

	echo -e "\n\e[0;97m$CMD_FILTERED\e[0;90m"
}

PRINT_ERR () {
	local MSG="$1"

	if [[ "$MSG" == *:* ]]; then
		local PREFIX="${MSG%%:*}"
		local REST="${MSG#*: }"
		echo -e "\n\e[1;91m${PREFIX}:\e[0m\e[0;31m ${REST}\e[0m" >&2
	else
		echo -e "\n\e[1;91m${MSG}\e[0m" >&2
	fi
}

GIT_STASH () {
	# Scan all unmerged paths and auto-stage any that no longer contain conflict markers
	for FILE in $(git diff --name-only --diff-filter=U); do
		if ! grep -qE '^(<<<<<<<|=======|>>>>>>>)( |$)' "$FILE"; then
			git add "$FILE"
			local CMD="git add '$FILE'"
			PRINT_CMD "$CMD"
			eval "$CMD"
		fi
	done

	# Capture current stash SHA (if any) to compare later
	local OLD_STASH=$(git rev-parse -q --verify refs/stash)

	local CMD="git stash push -u"
	PRINT_CMD "$CMD"
	eval "$CMD -m '$COMMANDLINE'"
	local STATUS=$?
	
	# Capture the new stash SHA
	local NEW_STASH=$(git rev-parse -q --verify refs/stash)

	if [[ $STATUS -ne 0 ]]; then
		local UNMERGED_FILES=$(git diff --name-only --diff-filter=U)
		if [[ -n "$UNMERGED_FILES" ]]; then
			PRINT_ERR "Stash failed because of conflict markers in files"
			while IFS= read -r FILE; do
				echo -e "\e[0;31m  - $FILE\e[0m" >&2
			done <<< "$UNMERGED_FILES"
		else
			PRINT_ERR "Stash failed"
		fi
		ABORT
	elif [[ "$OLD_STASH" != "$NEW_STASH" ]]; then
		STASH_REF="stash@{0}"
	fi
}

GIT_UNSTASH () {
	if [ -n "$STASH_REF" ]; then
		# Override color config just for this command:
		# - added (staged)     -> normal (removes green from successful merges)
		# - changed (unstaged) -> normal (removes red from standard mods)
		# - untracked          -> normal (removes red from new files)
		# - unmerged           -> red    (keeps critical conflicts red)
		local CMD="git -c color.status.added=normal -c color.status.changed=normal -c color.status.untracked=normal -c color.status.unmerged=red stash pop"
		PRINT_CMD "git stash pop"

		eval "$CMD '$STASH_REF'"
		unset STASH_REF
	fi
}

GIT_RUN_AND_HANDLE_CONFLICTS () {
	local OUTPUT STATUS # Needs to be separate for `$?` to work properly
	OUTPUT=$(eval "$*" 2>&1 | tee /dev/stderr)
	STATUS=$?

	if [[ $STATUS -ne 0 ]]; then
		if [[ "$OUTPUT" == *"CONFLICT ("* ]]; then
			PRINT_TEXT "%s – Resolve them and press %s to continue, or %s to cancel editing." 33 "Merge conflicts" "Enter" "Escape"
			CONTINUE_OR_ABORT

			GIT_ADD_ALL
			GIT_REBASE_CONTINUE
		elif [[ "$OUTPUT" == *"--allow-empty"* ]] || [[ "$OUTPUT" == *"No changes - did you forget to use"* ]]; then
			PRINT_TEXT "%s – Press %s to skip (drop) it, or %s to cancel editing." 33 "A later commit is now empty" "Enter" "Escape"
			CONTINUE_OR_ABORT

			GIT_ADD_ALL
			GIT_REBASE_CONTINUE "--skip"
		else
			PRINT_ERR "Unknown error during rebase."
			ABORT
		fi
	fi
}

GIT_REBASE_DROP () {
	# Determine if the oldest commit has a parent or is the first commit
	if git show -s --pretty=%P "$COMMIT" | grep -q .; then
		local CMD=(rebase --no-autostash --interactive "$COMMIT~")
	else
		local CMD=(rebase --no-autostash --interactive --root)
	fi
	PRINT_CMD "git ${CMD[*]} # -> drop"

	local SED_SCRIPT=""
	local DROP_COMMIT
	for DROP_COMMIT in "${COMMITS[@]}"; do
		SED_SCRIPT+=' -e "s/^pick '"${DROP_COMMIT:0:7}"'/drop '"${DROP_COMMIT:0:7}"'/"'
	done
	GIT_SEQUENCE_EDITOR=$'sed -i ""'"$SED_SCRIPT" \
	GIT_RUN_AND_HANDLE_CONFLICTS "git ${CMD[*]}"
}

GIT_REBASE_SQUASH () {
	local OP; if [[ -n $OPT_MESSAGE ]]; then OP=squash; else OP=fixup; fi

	# Determine rebase start point (parent of the oldest commit)
	local OLDEST="${COMMITS[1]}"
	if git show -s --pretty=%P "$OLDEST" | grep -q .; then
		local CMD=(rebase --no-autostash --interactive "$OLDEST~")
	else
		local CMD=(rebase --no-autostash --interactive --root)
	fi
	PRINT_CMD "git ${CMD[*]} # -> reorder+$OP"

	# Build `sed` script
	local SED_SCRIPT=""
	local APPEND_BLOCK=""
	local C
	for C in "${COMMITS[@]}"; do
		# If this commit is the target, skip it
		if [[ "$C" == "$TARGET" ]]; then
			continue
		fi
		SED_SCRIPT+=' -e "/^pick '"${C:0:7}"'/d" -e "/^squash '"${C:0:7}"'/d"'
		APPEND_BLOCK+=$'\\\\\n'"$OP ${C:0:7}"
	done

	# Execute rebase
	GIT_SEQUENCE_EDITOR=$'sed -i ""'"$SED_SCRIPT"$' -e "/^pick '"${TARGET:0:7}"'/a'"$APPEND_BLOCK"'"' \
	GIT_RUN_AND_HANDLE_CONFLICTS "git ${CMD[*]}"
}

GIT_REBASE_BEGIN_EDIT () {
	# Determine if commit has a parent or is the first commit
	if git show -s --pretty=%P "$COMMIT" | grep -q .; then
		local CMD=(rebase --no-autostash --interactive "$COMMIT~")
	else
		local CMD=(rebase --no-autostash --interactive --root)
	fi
	PRINT_CMD "git ${CMD[*]} # -> edit"

	GIT_SEQUENCE_EDITOR=$'sed -i "" -e "s/^pick '"${COMMIT:0:7}"'/edit '"${COMMIT:0:7}"'/"' \
	git "${CMD[@]}" || ABORT
}

GIT_ADD_ALL () {
	local CMD="git add --all"
	PRINT_CMD "$CMD"

	eval "$CMD" || ABORT
}

GIT_COMMIT_AMEND () {
	if [ ${#OPT_MESSAGE} -gt 0 ]; then
		local CMD="git commit --all --amend"
	else
		local CMD="git commit --all --amend --no-edit"
	fi
	PRINT_CMD "$CMD"

	eval "$CMD" || ABORT
}

GIT_REBASE_CONTINUE () {
	# First arg is the rebase sub-command, defaulting to "--continue"
	local SUBCMD="${1:---continue}"

	local CMD="git rebase $SUBCMD"
	PRINT_CMD "$CMD"

	# Only use the interactive editor if we are in "squash" mode AND `-m` was passed
	if [[ "$ACTION" == "squash" && -n "$OPT_MESSAGE" ]]; then
		GIT_RUN_AND_HANDLE_CONFLICTS "$CMD"
	else
		GIT_EDITOR=true \
		GIT_RUN_AND_HANDLE_CONFLICTS "$CMD"
	fi
}

GIT_REBASE_ABORT () {
	local GITDIR=$(git rev-parse --git-dir 2>/dev/null)
	if [[ -n "$GITDIR" && ( -d "$GITDIR/rebase-merge" || -d "$GITDIR/rebase-apply" ) ]]; then
		local CMD="git rebase --abort"
		PRINT_CMD "$CMD"

		eval "$CMD" 2>/dev/null
	fi
}

CONTINUE_OR_ABORT () {
	while true; do
		IFS= read -rs -k1 KEY
		case $KEY in
			''|$'\r'|$'\n') break ;;
			$'\e')          ABORT ;;
			*)              echo "Unknown key, try again." ;;
		esac
	done
}

ABORT () {
	GIT_REBASE_ABORT

	GIT_UNSTASH

	PRINT_ERR "Aborted."
	exit 1
}


# ---------------------------------------- ARGUMENT PARSING ----------------------------------------

# Remember full original command line
COMMANDLINE="git edit"
for ARG in "$@"; do
	COMMANDLINE+=" $(printf '%q' "$ARG")"
done

# -D pulls parsed flags out of $@
# -E allows flags/args and positionals to be mixed
# -F says fail if we find a flag that wasn't defined
# (the first dash is automatically handled, so long options are -opt, not --opt)
zmodload zsh/zutil
if ! zparseopts -D -E -F -- {m,-message}=OPT_MESSAGE {d,-drop}=OPT_DROP {s,-squash}:=OPT_SQUASH {h,-help}=OPT_HELP; then
	USAGE
	PRINT_ERR "Unknown option: $1"
	exit 1
fi

# -h/--help/help
if [[ ${#OPT_HELP} -gt 0 || $1 == "help" ]]; then
	USAGE
	exit 0
fi

# Conflict checks
if [ ${#OPT_MESSAGE} -gt 0 -a ${#OPT_DROP} -gt 0 ]; then
	USAGE
	PRINT_ERR "Options -m/--message and -d/--drop cannot be combined"
	exit 1
fi
if [ ${#OPT_DROP} -gt 0 -a ${#OPT_SQUASH} -gt 0 ]; then
	USAGE
	PRINT_ERR "Options -d/--drop and -s/--squash cannot be combined"
	exit 1
fi

COMMITS=()

if [ $# -eq 0 ]; then
	USAGE
	PRINT_ERR "Missing <commit> argument(s)"
	exit 1
fi

# Parse/expand arguments (commits or ranges)
for ARG in "$@"; do
	# Check if the argument is a standard ".." range (excluding "..." symmetric diff)
	if [[ "$ARG" == *".."* && "$ARG" != *"..."* ]]; then
		local S="${${ARG%%..*}:-HEAD}"
		local E="${${ARG#*..}:-HEAD}"

		# Swap if reversed (newer..older)
		git merge-base --is-ancestor "$E" "$S" 2>/dev/null && { local T="$S"; S="$E"; E="$T"; }

		# Determine range string (inclusive)
		local RANGE="$E"
		git rev-parse -q --verify "$S^" >/dev/null && RANGE="$S^..$E"

		# Validate and append
		if ! git rev-list "$RANGE" >/dev/null 2>&1; then
			PRINT_ERR "Invalid commit range: $ARG"
			exit 1
		fi
		COMMITS+=($(git rev-list "$RANGE"))
	else
		# Handle single commits
		if ! git rev-parse --quiet --verify "$ARG" >/dev/null 2>&1; then
			PRINT_ERR "Unknown <commit>: $ARG"
			exit 1
		fi
		COMMITS+=($(git rev-parse "$ARG"))
	fi
done

# Abort if no commits were found
if [ ${#COMMITS[@]} -eq 0 ]; then
	PRINT_ERR "No valid commits found."
	exit 1
fi

# Sort selected commits topologically (oldest first)
COMMITS=($(git rev-list --no-walk --reverse "${COMMITS[@]}"))

# Determine Action
if [ ${#OPT_DROP} -gt 0 ]; then
	# Drop/Delete (`-d` / `--drop`)
	ACTION="drop"
	COMMIT=${COMMITS[1]}

elif [ ${#OPT_SQUASH} -gt 0 ]; then
	# Explicit Squash (`-s=HASH` or `-s HASH`)
	ACTION="squash"

	# Determine target
	if [[ "${OPT_SQUASH[1]}" == "-s="* || "${OPT_SQUASH[1]}" == "--squash="* ]]; then
		TARGET=${OPT_SQUASH[1]#*=}
	elif [[ ${#OPT_SQUASH} -gt 1 && -n "${OPT_SQUASH[2]}" ]]; then
		TARGET=${OPT_SQUASH[2]}
	fi

	# If an explicit target was found, verify it and add to `COMMITS` array
	if [ -n "$TARGET" ]; then
		if ! git rev-parse --quiet --verify "$TARGET^{commit}" >/dev/null 2>&1; then
			PRINT_ERR "Unknown <target>: $TARGET"
			exit 1
		fi
		TARGET=$(git rev-parse "$TARGET")
		# Add explicit target to list and re-sort to ensure correct topological order
		COMMITS+=("$TARGET")
		COMMITS=($(git rev-list --no-walk --reverse "${COMMITS[@]}"))
	fi

	# Default target to oldest if not set
	if [ -z "$TARGET" ]; then
		TARGET=${COMMITS[1]}

		# If squashing just 1 commit (e.g. `git edit -s HEAD`), target is parent
		if [ ${#COMMITS[@]} -eq 1 ]; then
			if git cat-file -e "${TARGET}^" 2>/dev/null; then
				local PARENT=$(git rev-parse "${TARGET}^")
				TARGET=$PARENT
				COMMITS=($TARGET ${COMMITS[1]})
			else
				PRINT_ERR "Cannot squash <commit> as it has no parent"
				exit 1
			fi
		fi
	fi
	# Use newest commit for logs if needed, but logic uses `COMMITS` array
	COMMIT=${COMMITS[-1]}

elif [ ${#COMMITS[@]} -gt 1 ]; then
	# Implicit Squash (no flags, but multiple commits provided)
	ACTION="squash"
	TARGET=${COMMITS[1]}
	COMMIT=${COMMITS[-1]}

else
	# Edit (single commit, no flags)
	ACTION="edit"
	COMMIT=${COMMITS[1]}
fi


# ------------------------------------------- CORE LOGIC -------------------------------------------

GIT_STASH

if [[ "$ACTION" == "drop" ]]; then
	PRINT_ACTION "Dropping %s" "${COMMITS[@]}"

	PRINT_TEXT "Press %s to confirm, or cancel with %s." 35 "Enter" "Escape"
	CONTINUE_OR_ABORT

	GIT_REBASE_DROP
elif [[ "$ACTION" == "squash" ]]; then
	local TARGET_SUBJECT=$(git log -1 --pretty=format:'%s' "$TARGET")
	PRINT_ACTION "Merging %s -> ${TARGET:0:7}\e[22m (${TARGET_SUBJECT})" "${COMMITS[@]:#$TARGET}"

	PRINT_TEXT "Press %s to confirm, or cancel with %s." 35 "Enter" "Escape"
	CONTINUE_OR_ABORT

	GIT_REBASE_SQUASH
else
	PRINT_ACTION "Editing %s..." "$COMMIT"

	GIT_REBASE_BEGIN_EDIT

	PRINT_TEXT "%s – then press %s to continue, or cancel with %s." 35 "Now make your changes" "Enter" "Escape"
	CONTINUE_OR_ABORT

	GIT_ADD_ALL
	GIT_COMMIT_AMEND

	GIT_REBASE_CONTINUE
fi

GIT_UNSTASH

echo -e "\n\e[1;92mgit edit completed.\e[0m"
